name: CICD
on: push

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
       contents: read
       packages: write
       id-token: write
    steps:
      - uses: internetarchive/build@v1
        with:
          regpw: ${{ secrets.GITHUB_TOKEN }}


  # This workflow uses a `deno` binary along with `eslint` for code linting, and (optional) testing.
  #
  # NOTE: robotic image construction would be:
  #   image: ghcr.io/${{ github.repository }}:${{ github.ref_name }}

  lint:
    needs: build
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/internetarchive/dyno:main
    steps:
    - name: Setup repo
      uses: actions/checkout@v2
    - run: /app/lint


  # If your tests *don't* require pkgs or non-repo files from your docker build image,
  # then you can use this nicely for testing files in your repo like 'test/something.test.js'
  # along with a full code coverage report.
  test:
    needs: build
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/internetarchive/dyno:main
    steps:
    - name: Setup repo
      uses: actions/checkout@v2
    - run: /app/test/test.sh



  deploy:
    needs: [build, lint, test]
    runs-on: ubuntu-latest
    container:
      image: registry.gitlab.com/internetarchive/nomad/master
    steps:
    - env:
        NOMAD_ADDR: ${{ secrets.NOMAD_ADDR }}
        NOMAD_TOKEN: ${{ secrets.NOMAD_TOKEN }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        KUBE_INGRESS_BASE_DOMAIN: ${{ secrets.KUBE_INGRESS_BASE_DOMAIN }}
      run: /deploy.sh
